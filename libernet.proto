// The Libernet protocol.
//
// Copyright 2025 The Libernet Team
// SPDX-License-Identifier: Apache-2.0
//
//
// # General Notes
//
// ## Overview
//
// This file defines the protocol that must be implemented by all nodes of the Libernet network. The
// network is fully decentralized and the nodes communicate with each other using this gRPC protocol
// over SSL / TLS. Libernet clients such as the Libernet Browser also use this protocol when
// connecting to a node and sending requests.
//
// ## Cryptographic Primitives
//
// The protocol uses the BLS12-381 elliptic curve and for the most part runs on BLS12-381's finite
// fields.
//
// The protocol uses Poseidon-128 for hashing everywhere a scalar output is needed, but in some
// cases it uses SHA3. Our Poseidon-128 instance uses the x^5 S-box and T=3 (rate=2, capacity=1).
//
// ## Accounts
//
// Libernet accounts are managed via an elliptic curve keypair that's used by the owner to sign
// transactions and other kinds of messages. The private key is a BLS scalar but since it must
// remain secret we never serialize it in this protocol. The public key is a BLS point so we
// serialize it in compressed form using the `PointG1` message type. More often, Libernet accounts
// are identified by their address rather than their public key. The address of an account is a
// scalar calculated as follows:
//
//  * convert the public BLS key into its standard compressed form,
//  * hash the 48 bytes of the compressed key with SHA3-512,
//  * convert the SHA3-512 hash to a BLS scalar via modular reduction.
//
// ## Authentication
//
// All network connections used with this protocol must be authenticated on both sides with mTLS
// using special self-signed certificates. TODO: add more info.
//
// ## Signatures
//
// Some messages are cryptographically signed by the emitting node. These messages are generally
// structured as follows:
//
//   message SignedMessage {
//     message Payload {
//       // ...
//     }
//     optional google.protobuf.Any payload = 1;
//     optional Signature signature = 2;
//   }
//
// See `NodeIdentity` for an example.
//
// For this kind of messages, the `type_url` of the `Any` must be set to
// `type.libernet.org/fully.qualified.path.of.ThePayload` and the value must be the wire encoding of
// a `Payload` message. For example, the type_url of a `NodeIdentity` payload would be
// `type.libernet.org/libernet.NodeIdentity.Payload`.
//
// The attached signature refers to the bytes of the wire encoding of the `payload` field, which is
// an `Any` message wrapping the actual message. Using an `Any` achieves two important goals:
//
//   * it provides a type_url that acts as a domain separator, preventing misinterpretation attacks;
//   * and it clarifies that the signature refers to the bytes of the payload as encoded inside that
//     particular `Any` instance (the `Any` stores the encoded message as a raw byte array).
//
// The latter is important because protobuf encoding is not canonical: field ordering is not
// deterministic, it might have duplicated fields/tags, etc. But anyone wishing to verify the
// signature needs to know exactly the byte array to verify.
//
// Note that the need for a wrapping `Any` reintroduces the encoding problem one level above: `Any`
// has two fields (the type_url and the byte array) and it's unspecified which one is encoded first
// or whether a field is repeated more than once (the decoding is still unambiguous thanks to
// protobuf's Last One Wins rule). To address that we require that the whole `Any` is encoded
// canonically as follows:
//
//   * both fields must be present (as if they were required),
//   * field `type_url` (tagged 1) must be the first,
//   * field `value` (tagged 2) must be the second,
//   * there must be no repeated fields.
//
// Implementors don't need to modify their gRPC & protobuf frameworks to enforce this, they just
// need to know that when signing or verifying, the signed/verified message must be encoded this
// way. Implementing canonical encoding for a known, two-field protobuf is quite easy and much
// better than implementing it generically for any protobuf.
//
// Since canonical encoding is implemented only for the wrapping `Any`, the wrapped message cannot
// be re-encoded without changing the signature.

syntax = "proto2";

import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";
import "libernet_wasm.proto";

package libernet;

// Used by nodes and clients to communicate what version of this protocol they implement.
//
// The compatibility rules are:
//
//  * different major versions are incompatible,
//  * different minor versions and build numbers within compatible major versions are compatible,
//  * all nodes and clients MUST implement backward compatibility for at least the previous major
//    version.
//
// So the major version number must be bumped every time an incompatible change is implemented.
//
// Examples:
//
//  * 1.2.3 and 1.2.4 are compatible,
//  * 1.2.3 and 1.3.4 are compatible,
//  * 1.2.3 and 2.2.3 are incompatible but 1.2.3 is still supported,
//  * 1.2.3 and 3.2.3 are incompatible and 1.2.3 may no longer be supported.
//
// Major version 0 represents preliminary versions not ready for production use, and is granted the
// following exceptions to the above rules:
//
//  * different minor versions are incompatible if the major version is 0,
//  * there's no requirement to support the previous minor version within major version 0.
//
// Example:
//
//  * 0.1.2 and 0.2.3 are incompatible and 0.1.2 may no longer be supported.
//
// All versions within major version 0 must be considered unstable.
message ProtocolVersion {
  optional uint32 major = 1;
  optional uint32 minor = 2;
  optional uint32 build = 3;
}

// A BLS12-381 scalar.
message Scalar {
  // REQUIRED. The bytes of the scalar in little endian order. This field MUST be 32 bytes long.
  optional bytes value = 4;
}

// A BLS12-381 G1 point.
message PointG1 {
  // REQUIRED. The compressed bytes of the point. This field MUST be 48 bytes long.
  optional bytes compressed_bytes = 1;
}

// A BLS12-381 G2 point.
message PointG2 {
  // REQUIRED. The compressed bytes of the point. This field MUST be 96 bytes long.
  optional bytes compressed_bytes = 2;
}

// BLS signature used for various purposes.
//
// This protobuf doesn't contain the signed bytes themselves, those have to be transmitted
// separately.
//
// WARNING: signed messages should always contain nonces and/or timestamps, otherwise they're
// vulnerable to replay attacks.
message Signature {
  // REQUIRED. The account address of the signer.
  optional Scalar signer = 1;

  // REQUIRED. The public key of the signer. Note that the Poseidon hash of this point must equal
  // `signer` for the signature to be valid.
  optional PointG1 public_key = 3;

  // REQUIRED. The BLS signature output.
  optional PointG2 signature = 4;
}

// The descriptor of a block.
//
// This descriptor summarizes everything related to the block. `block_hash` is the hash of all
// fields and uniquely identifies the block.
message BlockDescriptor {
  optional Scalar block_hash = 1;
  optional uint64 chain_id = 2;
  optional fixed64 block_number = 3;
  optional Scalar previous_block_hash = 4;
  optional google.protobuf.Timestamp timestamp = 5;
  optional Scalar network_topology_root_hash = 6;
  optional Scalar transactions_root_hash = 7;
  optional Scalar accounts_root_hash = 8;
  optional Scalar program_storage_root_hash = 9;
}

// Describes the status of an account.
//
// This can be an externally owned account or a smartcontract alike.
message AccountInfo {
  // The latest transaction nonce used by the account. Zero means the account has never submitted
  // any transactions. Future transactions are rejected if their nonce is less than or equal to this
  // value.
  //
  // This field is unset for smartcontract accounts.
  optional uint64 last_nonce = 1 [default = 0];

  // REQUIRED. The LIB balance (in dan) associated to the account.
  optional Scalar balance = 2;

  // The staking balance (in dan) associated to the account. This field is filled in only for
  // accounts associated to nodes of the network; it's left empty for regular, non-staking accounts
  // or smartcontracts.
  optional Scalar staking_balance = 3;
}

// A signed transaction.
message Transaction {
  // Payload content for block reward transactions.
  //
  // Every block MUST have exactly one reward transaction for every node participating in the
  // network. They can be signed by anyone, but are typically signed by the same account the block
  // builder node is using to participate in the network.
  //
  // This transaction type cannot be broadcast via `BroadcastTransactionRequest`. Additionally, if
  // one or more nodes have either zero or more than one attributed block rewards, the block is
  // invalid.
  message BlockReward {
    optional Scalar recipient = 1;
    optional Scalar amount = 2;
  }

  // Payload content for LIB transfer transactions.
  message SendCoins {
    optional Scalar recipient = 1;
    optional Scalar amount = 2;
  }

  // Payload content for smartcontract deployment transactions.
  message CreateProgram {
    optional bytes bytecode = 1;
  }

  message Payload {
    optional uint64 chain_id = 1;
    optional uint64 nonce = 2;

    oneof transaction {
      BlockReward block_reward = 3;
      SendCoins send_coins = 4;
      CreateProgram create_program = 5;
    }
  }

  // The type URL must be `type.libernet.org/libernet.Transaction.Payload`.
  optional google.protobuf.Any payload = 1;

  // REQUIRED. All transactions are always signed by the sender and are always communicated along
  // with their signature.
  optional Signature signature = 2;
}

// A Merkle proof for a piece of storage.
//
// TODO: explain how to verify it and how to extract the requested value.
message MerkleProof {
  // REQUIRED. The descriptor of the block whose storage is being queried.
  optional BlockDescriptor block_descriptor = 1;

  // The full key of the queried storage location.
  optional Scalar key = 2;

  // The queried value. The exact type depends on the context where this proof is used. For example,
  // when querying account statuses via the `GetAccount` RPC the value is an `AccountInfo` message.
  optional google.protobuf.Any value = 3;

  // A node of the lookup path.
  message Node {
    repeated Scalar child_hashes = 1;
  }

  // The lookup path up to the root of the Merkle tree. The first node is the looked up leaf, while
  // the last one is the root.
  repeated Node path = 4;
}

// A Merkle multi-proof containing part of a Merkle tree.
//
// This format is more efficient than just serializing an array of `MerkleProof`s because the proven
// values can share common path prefixes in a partial tree. On the flipside, this format is harder
// to parse and requires the receiver to check that the serialized graph is a valid tree with the
// expected arity, depth, and no cycles. It also requires the keys of the proven values to be
// reconstructed from their respective paths, as they are not provided explicitly here (unlike
// `MerkleProof`).
//
// TODO: explain how to verify it and how to extract the requested values.
message MerkleMultiProof {
  // REQUIRED. The descriptor of the block whose storage is being queried.
  optional BlockDescriptor block_descriptor = 1;

  // A node of the tree.
  message Node {
    // Encodes a child of a node. Since we are encoding a partial tree, many children will be
    // specified just by their hash. For the nodes that are actually present we either specify
    // `node_index` (the index of an internal node relative to the `MerkleMultiProof.node` array) or
    // `leaf_index` (the index of a leaf node relative to the `MerkleMultiProof.value` array).
    message Child {
      oneof child {
        Scalar hash = 1;
        uint32 node_index = 2;
        uint32 leaf_index = 3;
      }
    }

    // REQUIRED. The hash of this node.
    optional Scalar hash = 1;

    // The children of this node. The number of elements MUST ALWAYS match the arity of the tree,
    // e.g. 2 elements for binary Merkle trees.
    repeated Child child = 2;
  }

  // The internal nodes of the tree.
  repeated Node node = 2;

  // The leaves of the tree, representing the values that have been proven.
  repeated google.protobuf.Any value = 3;
}

// Contains the geographical location of a node.
message GeographicalLocation {
  // The latitude expressed in minutes, ranging from -5400 (equal to -90 degrees) to 5400 (equal to
  // +90 degrees).
  optional int32 latitude = 1;

  // The longitude expressed in minutes, ranging from 0 (equal to 0 degrees) to 10800 (equal to 180
  // degrees).
  optional uint32 longitude = 2;
}

// Describes a node of the network.
message NodeIdentity {
  message Payload {
    // Protocol version implemented by the node, as indicated by the tags of the Git repository
    // containing this file.
    optional ProtocolVersion protocol_version = 1;

    // The globally unique ID of the network this node participates in.
    optional uint64 chain_id = 2;

    // Wallet address of the node. This is the address used to stake LIB and earn rewards for
    // participating in the network.
    optional Scalar account_address = 3;

    // Self-declared geographical location of the node.
    //
    // NOTE: it's in the node's best interest to declare an accurate location, otherwise it won't be
    // able to achieve a competitive serving SLO.
    optional GeographicalLocation location = 4;

    // The IP address other nodes can use to connect to this node. It can be an IPv4 address, an
    // IPv6 address, or a DNS name, but it must be in a canonical form that can be used to uniquely
    // identify the node. The protocol treats addresses opaquely so they are entirely self-declared,
    // but the address format must remaing consistent throughout participation. For example, a
    // dual-stack node cannot provide an IPv4 address and then switch to IPv6, or provide an IPv6
    // address in one format and then switch to a different format, etc. In order to change address,
    // a node must leave and re-join the network.
    optional string network_address = 5;

    // The TCP port where the node exposes this gRPC protocol.
    optional uint32 grpc_port = 6;

    // The TCP port where the node exposes this protocol as gRPC-web.
    optional uint32 http_port = 7;

    // The time of serialization of this message, used to avoid signature replay attacks.
    optional google.protobuf.Timestamp timestamp = 8;
  }

  // The encoded payload. The type URL must be `type.libernet.org/libernet.NodeIdentity.Payload`.
  //
  // NOTE: in the Dotakon protocol all connections are authenticated, so the account_address
  // provided in the identity MUST equal the authenticated address.
  optional google.protobuf.Any payload = 1;

  // Required as proof to propose slashing if a node tries to attack the network by e.g. repeatedly
  // changing geographical location causing many topology refactorings. Note that at present
  // changing geographical location is not allowed at all. If a node wants to physically move, it
  // needs to leave and re-join the network.
  optional Signature signature = 2;
}

// Requests the identity of a node.
message GetIdentityRequest {}

// Requests information about a block.
message GetBlockRequest {
  // The hash of the block to retrieve. If unspecified, this RPC will return the latest block.
  optional Scalar block_hash = 1;

  // If true, the list of hashes of all transactions of this block is included in the response.
  optional bool get_all_transaction_hashes = 2 [default = false];
}

// Returns information about a block.
message GetBlockResponse {
  // REQUIRED.
  optional BlockDescriptor block_descriptor = 1;

  // Provided only if `GetBlockRequest.get_all_transaction_hashes` was set to true, otherwise it's
  // empty.
  //
  // The list is already sorted chronologically: the first hash is that of the first transaction in
  // the block.
  //
  // These hashes can be arranged as the leaves of a binary Sparse Merkle Tree with height 32, and
  // the root hash of such tree must match `block_descriptor.transactions_root_hash`.
  repeated Scalar transaction_hash = 2;
}

// Requests to stream block headers as blocks are validated.
message BlockSubscriptionRequest {}

// Streamed in response to a `BlockSubscriptionRequest`.
message BlockSubscriptionResponse {
  // One or more descriptors for new blocks accepted into the chain known by this node.
  //
  // Elements are sorted in ascending chronological order (the first element is the oldest block,
  // the last is the youngest).
  //
  // Normally a node sends exactly one descriptor per slot back to the client, but if a better fork
  // shows up then the node will discard all blocks up to the youngest common ancestor and will send
  // a `BlockSubscriptionResponse` with all the headers of the fork blocks up to and excluding the
  // common ancestor. The block hash of the ancestor will show up as the `previous_block_hash` of
  // the first element of this array.
  repeated BlockDescriptor block_descriptor = 1;
}

// Describes the topology of the network.
message NetworkTopology {
  // Describes a "cluster", sometimes also known as a "clique", a set of nodes that are all
  // connected to each other.
  message Cluster {
    repeated NodeIdentity node = 1;
  }

  // The topology is a fully connected graph of clusters, so listing all the clusters is sufficient
  // to determine the whole topology.
  repeated Cluster cluster = 1;
}

// Requests the current network topology.
message GetTopologyRequest {}

// Requests the information of an account at the specified block. The specified account can be a
// smartcontract or EOA alike.
message GetAccountRequest {
  // An optional block hash (defaults to the latest block if unspecified).
  optional Scalar block_hash = 1;

  // REQUIRED: the address to query.
  optional Scalar account_address = 2;
}

// Returns the Merkle-proven information of an account at the specified block.
message GetAccountResponse {
  // The value inside the proof must be an `AccountInfo` message with type URL
  // `type.libernet.org/libernet.AccountInfo`. The key is the account address.
  optional MerkleProof account_proof = 1;
}

// Requests to stream an account's data (with Merkle proofs) as it changes.
message AccountSubscriptionRequest {
  // The address of the account whose changes must be streamed.
  optional Scalar account_address = 1;

  // When enabled, the node will stream a new proof for the specified account at every new block
  // even if nothing changed in the account. The default is disabled, meaning a new proof will be
  // sent back only when something changed.
  optional bool every_block = 2 [default = false];
}

// Streamed in response to an `AccountSubscriptionRequest`.
message AccountSubscriptionResponse {
  // One or more Merkle proofs describing the state of the account at several subsequent blocks.
  //
  // The value inside each proof must be an `AccountInfo` message with type URL
  // `type.libernet.org/libernet.AccountInfo`. The key must be the account address.
  //
  // Elements are sorted in ascending chronological order (the first element is related to the
  // oldest block, the last one to the youngest).
  //
  // Normally a node sends exactly one proof per slot back to the client, but if a better fork shows
  // up then the node will discard all blocks up to the youngest common ancestor and will send an
  // `AccountSubscriptionResponse` with all the proofs relative to the fork blocks up to and
  // excluding the common ancestor. The block hash of the ancestor will show up as the
  // `block_descriptor.previous_block_hash` field of the first element of this array.
  repeated MerkleProof account_proof = 1;
}

// Looks up a transaction by hash.
message GetTransactionRequest {
  // The hash of the transaction to look up.
  optional Scalar transaction_hash = 1;
}

// Returns the queried transactions.
message GetTransactionResponse {
  // REQUIRED. The value inside the proof must be a `Transaction` message with type URL
  // `type.libernet.org/libernet.Transaction`. The key is the transaction number within the block,
  // e.g. 0 for the first transaction of the block, 1 for the second, 2 for the third, and so on.
  optional MerkleProof transaction_proof = 1;
}

// Queries a set of transactions based on certain criteria.
message QueryTransactionsRequest {
  // Optionally constrains the address of the transaction signer.
  optional Scalar from_filter = 1;

  // Optionally constrains the recipient of `SendCoins` and `BlockReward` transactions.
  //
  // If specified, only `SendCoins` and `BlockReward` transactions will be returned.
  optional Scalar to_filter = 2;

  // Optionally constrains the oldest block (by hash or number) from which transactions are queried.
  // Queries up to the genesis block if this is unspecified.
  oneof start_block_filter {
    Scalar start_block_hash = 3;
    uint64 start_block_number = 4;
  };

  // Optionally constrains the youngest block (by hash or number) from which transactions are
  // queried. Queries up to the latest block if this is unspecified.
  oneof end_block_filter {
    Scalar end_block_hash = 5;
    uint64 end_block_number = 6;
  };

  enum SortOrder {
    TRANSACTION_SORT_ORDER_DESCENDING = 0;
    TRANSACTION_SORT_ORDER_ASCENDING = 1;
  }

  // Specifies the sort order of the results (transactions are sorted chronologically).
  //
  // Defaults to the descending order, meaning newest transactions are returned first.
  optional SortOrder sort_order = 7 [default = TRANSACTION_SORT_ORDER_DESCENDING];

  // REQUIRED. Specifies the maximum number of transactions to query.
  optional uint32 max_count = 8;
}

// Returns the queried transactions along with their inclusion proofs.
//
// The returned data can be specified in either of two formats: individual Merkle proofs (one for
// every transaction) or Merkle multi-proofs (one partial tree for every touched block). See the
// docs for `MerkleMultiProof` for more details about the tradeoffs.
message QueryTransactionsResponse {
  // Provides inclusion proofs for the returned transactions, one for every transaction. The proofs
  // follow the order specified in `QueryTransactionRequest.sort_order`.
  message IndividualProofs {
    repeated MerkleProof individual_proof = 1;
  }

  // Provides inclusion multi-proofs for the returned transactions, one for every touched block. The
  // proofs follow the order specified in `QueryTransactionRequest.sort_order`, but since they're
  // per-block the order of the individual transactions inside each proof must be reconstructed
  // based on the keys. The keys of the transaction Merkle tree of each block are zero-based
  // transaction numbers, i.e. the first transaction has key 0, the second one has key 1, and so on.
  // To reconstruct the desired order after extracting a map of <tx_number,tx_data> pairs from each
  // partial tree, the receiver can simply order the entries by transaction number in ascending or
  // descending order.
  message MultiProofs {
    repeated MerkleMultiProof multi_proofs = 1;
  }

  oneof transaction_proofs {
    IndividualProofs individual_proofs = 1;
    MultiProofs multi_proofs = 2;
  }
}

// Broadcasts a signed transaction.
//
// `BlockReward` transactions are not allowed here.
message BroadcastTransactionRequest {
  // REQUIRED. The transaction to broadcast.
  optional Transaction transaction = 1;

  // The TTL for the message.
  optional uint32 ttl = 2 [default = 0];
}

message BroadcastTransactionResponse {}

message BroadcastBlockRequest {
  // Proof that the sender was actually a leader for the slot.
  message LeaderElectionProof {
    // REQUIRED. The network ID. This prevents the proof from being replayed across networks.
    optional uint64 chain_id = 1;

    // REQUIRED. The slot number. This prevents the proof from being replayed across blocks.
    optional uint64 slot_number = 2;

    // REQUIRED. The previous block hash, which we use as per-slot randomness when seeding the VRF.
    optional Scalar previous_block_hash = 3;

    // REQUIRED. A BLS signature used as a VRF. The signed message includes the other fields of this
    // message (chain ID, slot number, and previous block hash), and the resulting output is used to
    // decide the leader for the slot.
    optional Signature verifiable_randomness = 4;
  }

  // REQUIRED.
  optional LeaderElectionProof leader_election_proof = 1;

  // The descriptor of the new block. If both this field and `block_diff` are missing it means the
  // node didn't produce any block during the slot.
  optional BlockDescriptor block_descriptor = 2;

  // Ordered list of transactions in the block. Receivers of this message must replay the
  // transactions on top of the parent block and verify that the resulting hashes describing the
  // final state match the ones in the `block_descriptor` field.
  repeated Transaction transaction = 3;

  // The TTL for the message.
  optional uint32 ttl = 4 [default = 0];
}

message BroadcastBlockResponse {}

service NodeServiceV1 {
  // Returns the identity of the node.
  rpc GetIdentity(GetIdentityRequest) returns (NodeIdentity);

  // Returns information about a specified block, or about the latest block.
  rpc GetBlock(GetBlockRequest) returns (GetBlockResponse);

  // Streams blocks headers as blocks are validated.
  //
  // Note that the returned blocks may not be final. See the doc snippets for
  // `BlockSubscriptionResponse` for details about fork handling.
  rpc SubscribeToBlocks(BlockSubscriptionRequest) returns (stream BlockSubscriptionResponse);

  // Returns the current topology of the network.
  rpc GetTopology(GetTopologyRequest) returns (NetworkTopology);

  // Returns all the information of an account at a given block number (or at the latest block).
  rpc GetAccount(GetAccountRequest) returns (GetAccountResponse);

  // Streams the Merkle proofs of an account as the account changes.
  //
  // Note that the proofs may be relative to blocks that are not final. See the doc snippets for
  // `AccountSubscriptionResponse` for details about fork handling.
  rpc SubscribeToAccount(AccountSubscriptionRequest) returns (stream AccountSubscriptionResponse);

  // Looks up a transaction by hash.
  rpc GetTransaction(GetTransactionRequest) returns (GetTransactionResponse);

  // Queries a set of transactions based on certain criteria.
  rpc QueryTransactions(QueryTransactionsRequest) returns (QueryTransactionsResponse);

  // Request to broadcast a new transaction.
  rpc BroadcastTransaction(BroadcastTransactionRequest) returns (BroadcastTransactionResponse);

  // Used by the leader(s) of a slot to publish a new block.
  rpc BroadcastNewBlock(BroadcastBlockRequest) returns (BroadcastBlockResponse);
}
